<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Edit Pool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta content="Premium Multipurpose Admin & Dashboard Template" name="description" />
  <meta content="Themesdesign" name="author" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <!-- App favicon -->
  <!-- <link rel="shortcut icon" href="assets/images/favicon.ico"> -->
  <link rel="icon" href="./assets/images/krinikIn_Logo.svg" type="image/x-icon">
  <!-- Bootstrap Css -->
  <link href="assets/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
  <!-- Icons Css -->
  <link href="assets/css/icons.min.css" rel="stylesheet" type="text/css" />
  <!-- App Css-->
  <link href="assets/css/app.css" rel="stylesheet" type="text/css" />



  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,300,0,0" />
</head>

<body data-topbar="colored">

  <!-- Begin page -->
  <div id="layout-wrapper">
    <header id="page-topbar" class="">
      <div class="navbar-header ">
        <div class="d-flex ">
          <!-- LOGO -->
          <div class="navbar-brand-box">
            <a href="./dashboard.html" class="logo logo-dark">
              <span class="logo-sm">
                
                <img src="./assets/images/krinikIn_Logo.svg" alt="" />
              </span>
              <span class="logo-lg">
              
                <img src="./assets/images/krinikIn_Logo.svg" alt=""  />
              </span>
            </a>

            <a href="index.html" class="logo logo-light ">
              <span class="logo-sm">
             
                <img src="./assets/images/krinikIn_Logo.svg" alt=""  />
              </span>
              <span class="logo-lg">
                
                <img src="./assets/images/krinikIn_Logo.svg" alt="" />
              </span>
            </a>
          </div>

          <button type="button" class="btn btn-sm px-3 font-size-24 header-item waves-effect " id="vertical-menu-btn">
            <i class="mdi mdi-backburger "></i>
          </button>

          <!-- App Search-->
          <!-- <form class="app-search d-none d-lg-block">
                            <div class="position-relative mt-3">
                                <input type="text" class="form-control" placeholder="Search...">
                                <span class="mdi mdi-magnify"></span>
                            </div>
                        </form> -->
        </div>

        <div class="  d-flex justify-content-center gap-4 time_show1">
          <div class="dropdown d-flex justify-content-end ms-2  " id="enterotpdiv">
            <!-- <button id="showotppage" type="button" class="btn btn-primary2  waves-effect" 
             >Enter OTP
            </button> -->
            
          </div>
        
          <div class="dropdown   dblock">
            <div id="time_show" class="btn-primary2  px-3">
            </div>
          </div>

          
        </div>
        
      </div>
    </header>

       <!-- ========== Left Sidebar Start ========== -->
       <div class="vertical-menu ">
        <div data-simplebar class="h-100 ">
          <!--- Sidemenu -->
          <div id="sidebar-menu" class="">
            <!-- Left Menu Start -->
            <ul class="metismenu list-unstyled " id="side-menu">
              <li class="menu-title">Menu</li>
  
              <li>
                <a href="./dashboard.html" class="waves-effect">
                  <div class=" icons-sm icon-set">
                    <span class="material-symbols-outlined icon-margin">
                      dashboard
                      </span>
                 
                  <span>Dashboard</span>
                  </div>
                </a>
              </li>
  
              <li>
                <a href="./user.html" class="waves-effect">
                  <div class="icons-sm icon-set">
                    <span class="material-symbols-outlined icon-margin">
                      person
                      </span>
                 
                  <span>User</span>
                </div>
                </a>
              </li>
  
              <li>
                <a href="javascript: void(0);" class=" ">
                  <div class="icons-sm icon-set ">
                    <span class="material-symbols-outlined icon-margin">
                      sports_cricket
                      </span>                    
                      <span class="has-arrow waves-effect ">Sports Configuration</span>
                                      
                    </div> 
                    
                  </a>
  
                <ul class="sub-menu" aria-expanded="false">
                  <li><a href="./manage-league.html">Manage Leagues</a></li>
                  <li><a href="./manage-team.html">Manage Teams</a></li>
                  <li><a href="./manage-player.html">Manage Players</a></li>
                </ul>
              </li>
              
              <li>
                <a href="javascript: void(0);" class=" ">
                  <div class="icons-sm icon-set ">
                    <span class="material-symbols-outlined icon-margin">
                      crossword
                      </span>                   
                      <span class="has-arrow has-arrow1 waves-effect ">Manage Contest</span>
                                      
                    </div> 
                    
                  </a>
  
                <ul class="sub-menu" aria-expanded="false">
                  <li><a href="./manage-match.html">Manage Match</a></li>
                  <li><a href="./manage-pool.html">Manage Pools</a></li>
                </ul>
              </li>
  
              <li class="otp-exempt" style="display:none">
                <a href="javascript: void(0);" class=" ">
                  <div class="icons-sm icon-set ">
                    <span class="material-symbols-outlined icon-margin">
                      receipt_long
                      </span>                 
                      <span class="has-arrow has-arrow2 waves-effect ">Transactions</span>
                                      
                    </div> 
                    
                  </a>
  
                <ul class="sub-menu" aria-expanded="false">
                  <li><a href="./all-transaction.html">All Transaction</a></li>
                  <li><a href="./wallet-transaction.html">Wallet Transaction</a></li>
                  <li><a href="./game-transaction.html">Game Transaction</a></li>
                </ul>
              </li>
  
              <li class="otp-exempt" style="display:none">
                <a href="./account-setting.html" class="waves-effect">
                  <div class="icons-sm icon-set ">
                    <span class="material-symbols-outlined icon-margin">
                      settings
                      </span>
                      <span>Account Setting</span>
                  </div>
                </a>
              </li>
  
              <li>
                <a href="" class="waves-effect " id="logoutButton">
                  <div class=" icons-sm icon-set ">
                    <span class="material-symbols-outlined icon-margin ">
                      logout
                      </span>
                      <span class="">Logout</span>
                  </div>
                </a>
              </li>
  
            
                      </ul>
          </div>
          <!-- Sidebar -->
        </div>
      </div>
      <!-- Left Sidebar End -->

    <!-- ============================================================== -->
    <!-- Start right Content here -->
    <!-- ============================================================== -->
    <div class="main-content">

      <div class="page-content">

        <!-- Page-Title -->
        <div class="page-title-box">
          <div class="container-fluid">
            <div class="row align-items-center">
              <div class="col-md-8">
                <h4 class="page-title mb-1">Edit Pool</h4>

              </div>

            </div>

          </div>
        </div>
        <!-- end page title end breadcrumb -->

        <div class="page-content-wrapper">
          <div class="container-fluid">
            <div class="row justify-content-center">
              <div class="col-xl-7 col-md-9 col-sm-11">
                <div class="card">
                  <div class="card-body">
                    <!-- <div class="container mt-5"> -->
                    <div class="form-group mb-3 row mb-0">
                      <div class="col-md-12">
                        <div class="form-group form-group-custom mb-4">
                          <select class="form-select" aria-label="Default select example" id="matchSelect">
                            <option selected value="">Select Match</option>
                          </select>
                          <span id="error-match" class="span-error"></span>
                        </div>

                        <div class="form-group form-group-custom mb-4">

                          <select class="form-select mt-3" aria-label="Default select example" id="poolTypeSelect">
                            <option selected value="">Select Pool Type</option>
                            <option value="Silver">Silver ( 2 Players without cap)</option>
                            <option value="Platinum">Platinum ( 2 Players with Cap)</option>
                            <option value="Gold">Gold ( 3 Players with C & VC)</option>
                          </select>
                          <span id="error-pool" class="span-error"></span>
                        </div>

                        <div class="form-group form-group-custom mb-4">


                          <input class="form-control mt-3" type="text" placeholder="Pool Name" id="poolNameInput">
                          <span id="error-pool-name" class="span-error"></span>
                        </div>


                        <div class="form-group form-group-custom mb-4">
                          <div class="input-group mt-3">
                            <input class="form-control" type="text" placeholder="Enter price" id="priceInput">
                            <button class="btn btn-primary" id="addPriceButton">Add
                              Price</button>
                          </div>

                          <span id="error-price" class="span-error"></span>
                        </div>


                        <div class="mt-3" id="priceList"></div>


                        <div class="form-group form-group-custom mb-4">

                          <input class="form-control mt-3" type="text" placeholder="Pool Winning Prize (9x)"
                            id="winningPrizeInput">
                          <span id="error-win-price" class="span-error"></span>
                        </div>

                        <div class="form-group form-group-custom  mb-4">
                          <div class="datepicker-wrapper">
                            <input class="form-control" type="text" name="match_start_date" id="fantasyStartDate"
                              placeholder="Fantacy Start Date">
                            <i id="calendarIconEnd" class="fas fa-calendar-alt date-icon2"></i>
                          </div>
                          <span id="error-fantacy-start-date" class="error-message" style="display: none;"></span>
                        </div>
                        <!-- <div class="form-group form-group-custom mb-4">
                          <div class="datepicker-wrapper">
                            <input class="form-control" type="text" name="match_end_date" id="fantasyEndDate"
                              placeholder="Fantacy End Date">
                            <i id="calendarIconStart" class="fas fa-calendar-alt date-icon"></i>
                          </div>
                          <span id="error-fantacy-end-date" class="error-message" style="display: none;"></span>
                        </div> -->

                        <div class="mt-4 text-center d-flex justify-content-center gap-5">
                          <button class="btn btn-primary" type="submit" id="submitButton">Submit</button>
                          <!-- <button class="btn btn-primary mt-3" id="submitButton">Submit</button> -->
                          <button class="btn btn-primary grey-btn" type="button" id="cancel-btn"
                            onclick="window.location.replace('./manage-pool.html')">Cancel</button>
                        </div>

                      </div>
                    </div>



                  </div>

                </div>






              </div>
            </div>

          </div>
        </div>
      </div>
      <!-- end col -->
    </div>
    <!-- end row -->



  </div>
  <!-- end container-fluid -->
  </div>
  <!-- end page-content-wrapper -->
  </div>
  <!-- End Page-content -->


  <footer class="footer">
    <div class="container-fluid">
      <div class="row">
        <div class="col-sm-6">
          2024 © Krinik.
        </div>
        <div class="col-sm-6">
          <div class="text-sm-end d-none d-sm-block">
            Crafted with <i class="mdi mdi-heart text-danger"></i> by Themesdesign
          </div>
        </div>
      </div>
    </div>
  </footer>
  </div>
  <!-- end main content-->

  </div>
  <!-- END layout-wrapper -->


  <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/js/bootstrap.bundle.min.js"></script>
  

    <script src="./assets/js/logout.js"></script>

  <!-- JAVASCRIPT -->
  <script src="assets/libs/jquery/jquery.min.js"></script>
  <script src="assets/libs/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="assets/libs/metismenu/metisMenu.min.js"></script>
  <script src="assets/libs/simplebar/simplebar.min.js"></script>
  <script src="assets/libs/node-waves/waves.min.js"></script>

  <script src="https://unicons.iconscout.com/release/v2.0.1/script/monochrome/bundle.js"></script>


  <script src="assets/js/app.js"></script>


  <!-- <script>
    document.addEventListener('DOMContentLoaded', async function () {
      const matchSelect = document.getElementById('matchSelect');
      const priceInput = document.getElementById('priceInput');
      const addPriceButton = document.getElementById('addPriceButton');
      const priceList = document.getElementById('priceList');
      const errorPrice = document.getElementById('error-price');
      let prices = [];
      let existingPool = []

      const noNumberOrWhitespaceRegex = /^(?!.*[\uD83C-\uDBFF\uDC00-\uDFFF])^[a-zA-Z0-9!@#\$%\^\&*\)\(+=._-]+(?: [a-zA-Z0-9!@#\$%\^\&*\)\(+=._-]+)*$/;
      const noNumberOrWhitespaceRegex1 = /^(?!.*[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}\u{1FB00}-\u{1FBFF}])^[a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*$/u;

      existingPool = await myFetch("https://krinik.pythonanywhere.com/add_pool_get/pool_id/", "GET")
      // existingPool = existingPool1

      console.log(existingPool)
      // Fetch match data from the API
      async function fetchMatchData() {
        try {
          const response = await fetch('https://krinik.pythonanywhere.com/match_get/');
          if (!response.ok) {
            console.error('Network response was not ok. Status:', response.status, 'Status Text:', response.statusText);
            throw new Error('Network response was not ok');
          }
          const data = await response.json();
          const matchData = data.data;

          // Populate the select dropdown with match display names
          matchData.forEach(match => {
            const option = document.createElement('option');
            option.value = match.match_display_name; // Use match display name as the value
            option.textContent = match.match_display_name;
            matchSelect.appendChild(option);
          });
        } catch (error) {
          console.error('Error fetching match data:', error);
        }
      }

      await fetchMatchData();

      const urlParams = new URLSearchParams(window.location.search);
      const id = urlParams.get('id');
      if (id) {
        try {
          const response = await fetch(`https://krinik.pythonanywhere.com/add_pool_get/pool_id/${id}/`, { method: "GET" });
          if (!response.ok) {
            throw new Error('Failed to fetch league data');
          }

          let leagueData = await response.json();
          console.log(leagueData.data)
          editplayerdata(leagueData.data);
        } catch (error) {
          console.error('Error fetching league data:', error);
        }
      } else {
        console.error("No id parameter found in the URL.");
      }


      function editplayerdata(response) {
        const selectMatch = document.getElementById('matchSelect'); // Get selected match display name
        const poolType = document.getElementById('poolTypeSelect');
        const poolName = document.getElementById('poolNameInput');
        const priceValues1 = document.getElementById('priceList');
        const winningPrize = document.getElementById('winningPrizeInput');
        const fantasyStartDate = document.getElementById('fantasyStartDate');
        // const fantasyEndDate = document.getElementById('fantasyEndDate');

        if (response) {
          // Populate form fields
          selectMatch.value = response.select_match.match_display_name // Get selected match display name
          console.log(selectMatch.value)
          poolType.value = response.pool_type
          poolName.value = response.pool_name
          priceValues1.values = response.price.map((price, index) => {
            const div = document.createElement('div');
            div.className = 'price-item';
            div.innerHTML = `${price} <span onclick="removePrice(${index})">&times;</span>`;
            priceList.appendChild(div);
            return price;
          });

          prices = [...priceValues1.values]; // Initialize prices array with fetched prices
          console.log("Initialized prices array:", prices);
          // console.log(prices.value)
          winningPrize.value = `${response.winning_price}x`

          fantasyStartDate.value = response.fantacy_start_date
          // fantasyEndDate.value = response.fantacy_end_date

          // Store initial data
          initialData = {

            select_match: matchSelect.value,
            pool_type: poolType.value,
            pool_name: poolName.value,
            price: prices, // Ensure this variable is defined
            winning_price: parseFloat(winningPrize.value),
            fantacy_start_date: fantasyStartDate.value,
            // fantacy_end_date: fantasyEndDate.value
          };

          console.log('Initial data set:', initialData);
        } else {
          console.error("Data is not in the expected format:", response);
        }
      }



      async function myFetch(url, type, data) {
        try {
          let responseData;

          if (type === "GET") {
            const res = await fetch(url, {
              method: type,
              headers: {
                'Content-Type': 'application/json'
              }
            });

            if (res.ok) {
              console.log("HTTP request successful");
            } else {
              console.log("HTTP request unsuccessful");
            }

            responseData = await res.json();
            return responseData.data; // Assuming the API returns data array
          } else if (type === "DELETE") {
            const res = await fetch(url, {
              method: type,
              headers: {
                'Content-Type': 'application/json'
              }
            });

            if (res.ok) {
              console.log("HTTP request successful");
            } else {
              console.log("HTTP request unsuccessful");
            }

            return res;
          } else if (type === "POST" || type === "PUT") {
            const res = await fetch(url, {
              method: type,
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(data)
            });

            if (res.ok) {
              console.log("HTTP request successful");
            } else {
              console.log("HTTP request unsuccessful");
            }

            responseData = await res.json();
            return responseData;
          }
        } catch (error) {
          console.error("Fetch error:", error);
          throw error; // Re-throw the error to handle it where myFetch is called
        }
      }



      $(function () {
        let startPicker = flatpickr('#fantasyStartDate', {
          dateFormat: 'd-m-Y H:i',
          enableTime: true,
          minDate: 'today', // Disable past dates
          onChange: function (selectedDates, dateStr, instance) {
            if (selectedDates.length > 0) {
              endPicker.set('minDate', selectedDates[0]);
              // Close the picker if both date and time are selected
              // if (dateStr.includes(' ')) {
              //     instance.close(); // Close the picker after full date-time selection
              // }
            }
          },
          onReady: function (selectedDates, dateStr, instance) {
            addCustomButtons(instance, '#fantasyStartDate');
          }
        });

        // let endPicker = flatpickr('#fantasyEndDate', {
        //   dateFormat: 'd-m-Y H:i',
        //   enableTime: true,
        //   onOpen: function () {
        //     const startDate = startPicker.selectedDates[0];
        //     if (startDate) {
        //       endPicker.set('minDate', startDate);
        //     }
        //   },
        //   onChange: function (selectedDates, dateStr, instance) {
        //     if (selectedDates.length > 0) {
        //       // Close the picker if both date and time are selected
        //       // if (dateStr && dateStr.includes(' ')) {
        //       //     instance.close(); // Close the picker after full date-time selection
        //       // }
        //     }
        //   },
        //   onReady: function (selectedDates, dateStr, instance) {
        //     addCustomButtons(instance, '#fantasyEndDate');
        //   }
        });

        // Open Flatpickr on calendar icon click
        $('#calendarIconStart').click(function () {
          startPicker.open();
        });
        $('#calendarIconEnd').click(function () {
          endPicker.open();
        });
        let okButtonClicked = false;



        function addCustomButtons(instance, inputSelector) {
          // Ensure the calendarContainer is available
          if (!instance || !instance.calendarContainer) {
            console.error('Flatpickr instance or calendar container not found.');
            return;
          }

          // Check if the footer already exists and remove it
          let existingFooter = instance.calendarContainer.querySelector('.flatpickr-footer');
          if (existingFooter) {
            existingFooter.remove();
          }

          // Create footer and buttons
          const footer = document.createElement('div');
          footer.className = 'flatpickr-footer';

          const okButton = document.createElement('button');
          okButton.type = 'button';
          okButton.className = 'flatpickr-ok-button';
          okButton.textContent = 'OK';
          okButton.addEventListener('click', function () {
            okButtonClicked = true;
            instance.close();
          });

          const clearButton = document.createElement('button');
          clearButton.type = 'button';
          clearButton.className = 'flatpickr-clear-button';
          clearButton.textContent = 'Clear';
          clearButton.addEventListener('click', function () {
            document.querySelector(inputSelector).value = '';
            instance.clear();
          });

          footer.appendChild(okButton);
          footer.appendChild(clearButton);

          // Append the footer to the calendar container
          instance.calendarContainer.appendChild(footer);
        }

        // Modify the onChange event handler to only update the input value when the OK button is clicked
        instance.config.onChange = function (selectedDates, dateStr, instance) {
          if (okButtonClicked) {
            document.querySelector(inputSelector).value = dateStr;
            okButtonClicked = false; // Reset the flag
          }
        };
      });


      function updatePriceList() {
        priceList.innerHTML = '';
        prices.forEach((price, index) => {
          const div = document.createElement('div');
          div.className = 'price-item';
          div.innerHTML = `${price} <span onclick="removePrice(${index})">&times;</span>`;
          priceList.appendChild(div);
        });
        
      }


      // Function to add a new price
      addPriceButton.addEventListener('click', function () {
        const price = parseFloat(priceInput.value);
        if (!isNaN(price) && !prices.includes(price)) {
          prices.push(price); // Add the new price to the prices array
          updatePriceList();
          priceInput.value = '';
          if (checkPriceValidation()) {
            checkPriceValidation();
          }
        }
      });





      function checkPriceValidation() {
        if (prices.length === 0) {
          errorPrice.innerHTML = 'Price list cannot be empty';
          errorPrice.style.display = 'block';
          return false
        } else {
          errorPrice.style.display = 'none';
          return true
        }
      }


      window.removePrice = function (index) {
        prices.splice(index, 1);
        updatePriceList();
        // if (checkPriceValidation()) {
        //   checkPriceValidation()
        // }
      }

      document.getElementById('winningPrizeInput').addEventListener('input', function (event) {
        let value = this.value.replace(/\D/g, ''); // Remove any non-digit characters

        if (value) {
          this.value = `${value}x`; // Append 'X' at the end
        } else {
          this.value = ''; // Ensure the input is empty when value is empty
        }
      });

      document.getElementById('winningPrizeInput').addEventListener('keydown', function (event) {
        if (event.key === 'Backspace' || event.key === 'Delete') {
          let value = this.value.replace('x', ''); // Remove 'X' if present
          value = value.slice(0, -1); // Remove the last digit

          if (value) {
            this.value = `${value}x`; // Append 'X' at the end
          } else {
            this.value = ''; // Ensure the input is empty when value is empty
          }

          // Prevent the default backspace action
          event.preventDefault();
        }
      });
      // function checkPoolOverlap(selectMatch, poolName, startDate1, existingPool) {
        function checkPoolOverlap(selectMatch, poolName, existingPool) {

        // const startDate = document.getElementById('fantasyStartDate').value;
        if (!existingPool || existingPool.length === 0) {
          return { matchNameOverlap: false, poolNameOverlap: false, };
        }

        const normalizedName = selectMatch.trim().toLowerCase();
        const normalizedShortName = poolName.trim().toLowerCase();

        const matchNameOverlap = existingPool.some(match => {
          const normalizedExistingName = match.select_match.match_display_name.trim().toLowerCase();
          return normalizedExistingName === normalizedName;
        });

        const poolNameOverlap = existingPool.some(league => {
          const normalizedExistingShortName = league.pool_name.trim().toLowerCase();
          return normalizedExistingShortName === normalizedShortName;
        });

        // const dateOverlap = existingPool.some(match => {
        //   const matchStartDateStr1 = match.fantacy_start_date;
        //   ;
        //   const [day, month, year] = matchStartDateStr1.split(/[- ]+/);
        //   const matchStartDateStr = `${day}-${month}-${year}`;

        //   const startDateStr = startDate;
        //   const [startDay, startMonth, startYear] = startDateStr.split(/[- ]+/);
        //   const startDateObj = `${startDay}-${startMonth}-${startYear}`;

        //   return startDateObj === matchStartDateStr;
        // });
        // console.log('Date Overlap:', dateOverlap);
        console.log(matchNameOverlap , "okkk2")
        return { matchNameOverlap, poolNameOverlap, };
      }

      function validateMatchSelection() {
        const matchSelect = document.getElementById('matchSelect');
        const errorSpan = document.getElementById('error-match');

        if (!matchSelect || !errorSpan) {
          console.error('Match selection elements not found');
          return false;
        }



        function validate() {
          if (matchSelect.value === '') {
            errorSpan.innerHTML = 'Please select a match';
            errorSpan.style.display = 'inline';
            return false;
          } else {
            errorSpan.style.display = 'none';
            return true;
          }
        }


        matchSelect.addEventListener('change', validate);
        // poolSelect.addEventListener('change', validate1);
        return validate()
      }


      function validateoPoolSelection() {

        const poolSelect = document.getElementById('poolTypeSelect');
        const errorpoolSpan = document.getElementById('error-pool');


        if (!poolSelect || !errorpoolSpan) {
          console.error('Pool selection elements not found');
          return false;
        }


        function validate() {
          if (poolSelect.value === '') {
            errorpoolSpan.innerHTML = 'Please select a pool';
            errorpoolSpan.style.display = 'inline';
            return false;
          } else {
            errorpoolSpan.style.display = 'none';
            return true;
          }
        }

        poolSelect.addEventListener('change', validate);
        return validate()
      }

      function validateInput(inputId, errorId, regex, emptyMessage, invalidMessage) {
        const input = document.getElementById(inputId);
        const error = document.getElementById(errorId);

        function validate() {
          const value = input.value.trim();
          if (value === '') {
            error.innerHTML = emptyMessage;
            error.style.display = 'inline';
            return false;
          } else if (!regex.test(value)) {
            error.innerHTML = invalidMessage;
            error.style.display = 'inline';
            return false;
          } else {
            error.style.display = 'none';
            return true;
          }
        }

        input.addEventListener('input', validate);
        input.addEventListener('change', validate);

        return validate();
      }

      function validateMatchDates() {
        const startDate = document.getElementById('fantasyStartDate');
        // const endDate = document.getElementById('fantasyEndDate');
        const errorSpanStart = document.getElementById('error-fantacy-start-date');
        // const errorSpanEnd = document.getElementById('error-fantacy-end-date');

        function validateDate(dateInput, errorSpan) {
          if (!dateInput || !errorSpan) {
            console.error('Date input elements not found');
            return false;
          }

          function validate() {
            if (!dateInput.value) {
              errorSpan.innerHTML = 'Please select a date';
              errorSpan.style.display = 'inline';
              return false;
            } else {
              errorSpan.style.display = 'none';
              return true;
            }
          }

          dateInput.addEventListener('change', validate);
          return validate();
        }

        const validStartDate = validateDate(startDate, errorSpanStart);
        // const validEndDate = validateDate(endDate, errorSpanEnd);

        // return validStartDate && validEndDate;
        return validStartDate;

      }


      function validateForm() {
        const MatchValid = validateMatchSelection();
        const PoolValid = validateoPoolSelection();

        const isValidPoolName = validateInput(
          'poolNameInput',
          'error-pool-name',
          noNumberOrWhitespaceRegex,
          'Please enter a pool name',
          'Please enter a valid pool name'
        );

        const isValidWinningPrice = validateInput(
          'winningPrizeInput',
          'error-win-price',
          noNumberOrWhitespaceRegex1,
          'Please enter a winning price',
          'Please enter a valid winning price'
        );

        isPriceAdd = checkPriceValidation()
        // const teamValid = validateTeamSelection();
        // const playerValid = validatePlayerSelection();
        const datesValid = validateMatchDates();

        return MatchValid && datesValid && PoolValid && isValidPoolName && isPriceAdd && isValidWinningPrice;
        // return MatchValid  && PoolValid && isValidPoolName && isPriceAdd && isValidWinningPrice;

      }

      async function submitPoolData(data, method) {
        const formData = new FormData();


        formData.append('select_match', data.select_match);
        formData.append('pool_type', data.pool_type);
        formData.append('pool_name', data.pool_name);

        // Append each price individually
        data.price.map(price => {
          formData.append('price', [price]);
        });

        formData.append('winning_price', data.winning_price);
        formData.append('fantacy_start_date', data.fantacy_start_date);
        // formData.append('fantacy_end_date', data.fantacy_end_date);

        // Log formData keys and values
        formData.forEach((value, key) => {
          console.log(key, value);
        });
        try {
          const response = await fetch(`https://krinik.pythonanywhere.com/add_pool_get/pool_id/${id}/`, {
            method: method,
            body: formData
          });

          if (!response.ok) {
            throw new Error('Failed to add pool');
          }

          const responseData = await response.json();
          console.log('Success:', responseData.data);
          window.location.href = './manage-pool.html';
        } catch (error) {
          console.error('Error:', error);
          alert('An error occurred while adding the pool. Please try again later.');
        }
      }





      document.getElementById('submitButton').addEventListener('click', async function () {
        // const selectMatch = matchSelect.value; // Get selected match display name
        const selectMatch = document.getElementById('matchSelect').value;
        //  const priceValues1 = document.getElementById('priceList');

        
        const poolType = document.getElementById('poolTypeSelect').value;
        const poolName = document.getElementById('poolNameInput').value;
        const winningPrize = parseFloat(document.getElementById('winningPrizeInput').value);
        const fantasyStartDate = document.getElementById('fantasyStartDate').value;
        // const fantasyEndDate = document.getElementById('fantasyEndDate').value;
        const startDate1 = fantasyStartDate;
        // priceValues1.values = price.map((price, index) => {
        //     const div = document.createElement('div');
        //     div.className = 'price-item';
        //     div.innerHTML = `${price} <span onclick="removePrice(${index})">&times;</span>`;
        //     priceList.appendChild(div);
        //     return price;
        //   });
        // prices = [...priceValues1.value]



        const currentData = {
          select_match: selectMatch,
          pool_type: poolType,
          pool_name: poolName,
          price: prices,
          winning_price: winningPrize,
          fantacy_start_date: fantasyStartDate,
          // fantacy_end_date: fantasyEndDate
        };

        // currentData.forEach(play =>{
        //   console.log(currentData)
        // })
        console.log(currentData, "ok")
        // const overlapResult = checkPoolOverlap(selectMatch, poolName, startDate1, existingPool);
        const overlapResult = checkPoolOverlap(selectMatch, poolName, existingPool);



        if (validateForm()) {

          const errorMatchName = document.getElementById('error-match');
                    const errorPoolName = document.getElementById('error-pool-name');

          const hasMatchChanged = currentData.select_match !== initialData.select_match;

          const hasPoolTypeChanged = currentData.pool_type !== initialData.pool_type;
          const hasPoolNameChanged = currentData.pool_name !== initialData.pool_name;
          const hasWinningPriceChanged = currentData.winning_price !== initialData.winning_price;
          const hasPriceChanged = currentData.price !== initialData.price;

          if (hasPoolTypeChanged || hasWinningPriceChanged || hasPriceChanged) {
            if (confirm("Are you sure you want to add this match?")) {
              try {
                submitPoolData(currentData, 'PATCH');
              } catch (error) {
                console.error('Error:', error);
              }
            }
          // } else if(hasMatchChanged && hasPoolNameChanged ){
          //   if (overlapResult.matchNameOverlap && overlapResult.poolNameOverlap) {
          //       document.getElementById('error-match').innerHTML = 'Match already exists';
          //       document.getElementById('error-match').style.display = 'inline';
          //       document.getElementById('error-pool-name').innerHTML = 'Pool name already exists';
          //       document.getElementById('error-pool-name').style.display = 'inline';
          //     } else {
          //       if (confirm("Are you sure you want to add this match?")) {
          //         try {
          //           submitPoolData(currentData, 'PATCH');
          //         } catch (error) {
          //           console.error('Error:', error);
          //         }
          //       }
          //     }
          // }
          // else if (hasMatchChanged ) {
          //     if (overlapResult.matchNameOverlap && overlapResult.poolNameOverlap) {
          //       document.getElementById('error-match').innerHTML = 'Match already exists';
          //       document.getElementById('error-match').style.display = 'inline';
          //       // document.getElementById('error-pool-name').innerHTML = 'Pool name already exists';
          //       // document.getElementById('error-pool-name').style.display = 'inline';
          //     } else {
          //       if (confirm("Are you sure you want to add this match?")) {
          //         try {
          //           submitPoolData(currentData, 'PATCH');
          //         } catch (error) {
          //           console.error('Error:', error);
          //         }
          //       }
          //     }
          //   }
          //   else if(hasPoolNameChanged){
          //     if (overlapResult.matchNameOverlap && overlapResult.poolNameOverlap) {
          //       // document.getElementById('error-match').innerHTML = 'Match already exists';
          //       // document.getElementById('error-match').style.display = 'inline';
          //       document.getElementById('error-pool-name').innerHTML = 'Pool name already exists';
          //       document.getElementById('error-pool-name').style.display = 'inline';
          //     } else {
          //       if (confirm("Are you sure you want to add this match?")) {
          //         try {
          //           submitPoolData(currentData, 'PATCH');
          //         } catch (error) {
          //           console.error('Error:', error);
          //         }
          //       }
          //     }
            }      
            else {

              if (hasMatchChanged) {
                            const MatchNameOverlap = checkPoolOverlap(currentData.select_match, initialData.pool_name, existingPool);
                            if (MatchNameOverlap) {
                                errorMatchName.innerHTML = 'Match name already exists';
                                errorMatchName.style.display = 'inline';
                            } else {
                                if (hasPoolNameChanged) {
                                    const poolNameOverlap = checkPoolOverlap(initialData.select_match, currentData.pool_name, existingPool);
                                    if (poolNameOverlap) {
                                        errorPoolName.innerHTML = 'Pool name already exists';
                                        errorPoolName.style.display = 'inline';
                                    } else {
                                        if (confirm("are you confirm to edit it?")) {

                                            await submitFormData(currentData, 'PATCH');
                                        }
                                    }
                                } else {
                                    if (confirm("are you confirm to edit it?")) {

                                        await submitFormData(currentData, 'PATCH');
                                    }
                                }
                            }
                        } else if (hasPoolNameChanged) {
                            const poolNameOverlap = checkPoolOverlap(initialData.select_match, currentData.pool_name, existingPool);

                            if (poolNameOverlap) {
                                errorPoolName.innerHTML = 'Pool name already exists';
                                errorPoolName.style.display = 'inline';
                            } else {
                                if (confirm("are you confirm to edit it?")) {

                                    await submitFormData(currentData, 'PATCH');
                                }
                            }
                        } else {
                            if (confirm("are you confirm to edit it?")) {


                                await submitFormData(initialData, 'PATCH');
                            }
                        }
                    

              // if (confirm("Are you sure you want to add this match?")) {
              //   try {
              //     submitPoolData(initialData, 'PATCH');
              //   } catch (error) {
              //     console.error('Error:', error);
              //   }
              // }
            }
          } else {
          console.log('Form validation failed. Please check all fields.');
        }

      });
    // });

  </script> -->

  <script>
    document.addEventListener('DOMContentLoaded', async function () {
      const matchSelect = document.getElementById('matchSelect');
      const priceInput = document.getElementById('priceInput');
      const addPriceButton = document.getElementById('addPriceButton');
      const priceList = document.getElementById('priceList');
      const errorPrice = document.getElementById('error-price');
      let prices = [];
      let existingPool = []

      const noNumberOrWhitespaceRegex = /^(?!.*[\uD83C-\uDBFF\uDC00-\uDFFF])^[a-zA-Z0-9!@#\$%\^\&*\)\(+=._-]+(?: [a-zA-Z0-9!@#\$%\^\&*\)\(+=._-]+)*$/;
      const noNumberOrWhitespaceRegex1 = /^(?!.*[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}\u{1FB00}-\u{1FBFF}])^[a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*$/u;
      const alphanumericRegex = /^[a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*$/u;
      existingPool = await myFetch("https://krinik.pythonanywhere.com/add_pool_get/", "GET")
      // existingPool = existingPool1

      console.log(existingPool)
      // Fetch match data from the API
      async function fetchMatchData() {
        try {
          const response = await fetch('https://krinik.pythonanywhere.com/match_get/');
          if (!response.ok) {
            console.error('Network response was not ok. Status:', response.status, 'Status Text:', response.statusText);
            throw new Error('Network response was not ok');
          }
          const data = await response.json();
          const matchData = data.data;

          // Populate the select dropdown with match display names
          matchData.forEach(match => {
            const option = document.createElement('option');
            option.value = match.match_display_name; // Use match display name as the value
            option.textContent = match.match_display_name;
            matchSelect.appendChild(option);
          });
          initializeDatePickers();
        } catch (error) {
          console.error('Error fetching match data:', error);
        }
      }

      await fetchMatchData();

      const urlParams = new URLSearchParams(window.location.search);
      const id = urlParams.get('id');
      console.log(id,"id che")
      if (id) {
        try {
          const response = await fetch(`https://krinik.pythonanywhere.com/add_pool_get/pool_id/${id}/`, { method: "GET" });
          if (!response.ok) {
            throw new Error('Failed to fetch league data');
          }

          let leagueData = await response.json();
          console.log(leagueData.data)
          editplayerdata(leagueData.data);
        } catch (error) {
          console.error('Error fetching league data:', error);
        }
      } else {
        console.error("No id parameter found in the URL.");
      }


      function editplayerdata(response) {
        const selectMatch = document.getElementById('matchSelect'); // Get selected match display name
        const poolType = document.getElementById('poolTypeSelect');
        const poolName = document.getElementById('poolNameInput');
        const priceValues1 = document.getElementById('priceList');
        const winningPrize = document.getElementById('winningPrizeInput');
        const fantasyStartDate = document.getElementById('fantasyStartDate');
        // const fantasyEndDate = document.getElementById('fantasyEndDate');

        if (response) {
          // Populate form fields
          selectMatch.value = response.select_match.match_display_name // Get selected match display name
          console.log(selectMatch.value)
          poolType.value = response.pool_type
          poolName.value = response.pool_name
          priceValues1.values = response.price.map((price, index) => {
            const div = document.createElement('div');
            div.className = 'price-item';
            div.innerHTML = `${price} <span onclick="removePrice(${index})">&times;</span>`;
            priceList.appendChild(div);
            return price;
          });

          prices = [...priceValues1.values]; // Initialize prices array with fetched prices
          console.log("Initialized prices array:", prices);
          // console.log(prices.value)
          winningPrize.value = `${response.winning_price}x`

          fantasyStartDate.value = response.fantacy_start_date
          // fantasyEndDate.value = response.fantacy_end_date

          // Store initial data
          initialData = {

            select_match: matchSelect.value,
            pool_type: poolType.value,
            pool_name: poolName.value,
            price: prices, // Ensure this variable is defined
            winning_price: parseFloat(winningPrize.value),
            fantacy_start_date: fantasyStartDate.value,
            // fantacy_end_date: fantasyEndDate.value
          };

          console.log('Initial data set:', initialData);
        } else {
          console.error("Data is not in the expected format:", response);
        }
      }



      async function myFetch(url, type, data) {
        try {
          let responseData;

          if (type === "GET") {
            const res = await fetch(url, {
              method: type,
              headers: {
                'Content-Type': 'application/json'
              }
            });

            if (res.ok) {
              console.log("HTTP request successful");
            } else {
              console.log("HTTP request unsuccessful");
            }

            responseData = await res.json();
            return responseData.data; // Assuming the API returns data array
          } else if (type === "DELETE") {
            const res = await fetch(url, {
              method: type,
              headers: {
                'Content-Type': 'application/json'
              }
            });

            if (res.ok) {
              console.log("HTTP request successful");
            } else {
              console.log("HTTP request unsuccessful");
            }

            return res;
          } else if (type === "POST" || type === "PUT") {
            const res = await fetch(url, {
              method: type,
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(data)
            });

            if (res.ok) {
              console.log("HTTP request successful");
            } else {
              console.log("HTTP request unsuccessful");
            }

            responseData = await res.json();
            return responseData;
          }
        } catch (error) {
          console.error("Fetch error:", error);
          throw error; // Re-throw the error to handle it where myFetch is called
        }
      }



      function initializeDatePickers() {
    const matchDisplayName = matchSelect.value; // Get the selected match display name
    const matchDateTime = getMatchEndDateTime(matchDisplayName); // Assuming this function extracts end date and time

    // Initialize the start date picker
    const startPicker = flatpickr('#fantasyStartDate', {
        dateFormat: 'd-m-Y H:i',
        enableTime: true,
        minDate: 'today', // Disable past dates
        maxDate: matchDateTime.date, // Set the max date to the match date
        maxTime: matchDateTime.time, // Set the max time to the match time
        onReady: function (selectedDates, dateStr, instance) {
            addCustomButtons(instance, '#fantasyStartDate');
        }
    });

    // Add custom buttons to the picker
    function addCustomButtons(instance, inputSelector) {
        if (!instance || !instance.calendarContainer) {
            console.error('Flatpickr instance or calendar container not found.');
            return;
        }

        let existingFooter = instance.calendarContainer.querySelector('.flatpickr-footer');
        if (existingFooter) {
            existingFooter.remove();
        }

        const footer = document.createElement('div');
        footer.className = 'flatpickr-footer';

        const okButton = document.createElement('button');
        okButton.type = 'button';
        okButton.className = 'flatpickr-ok-button';
        okButton.textContent = 'OK';
        okButton.addEventListener('click', function () {
            instance.close();
        });

        const clearButton = document.createElement('button');
        clearButton.type = 'button';
        clearButton.className = 'flatpickr-clear-button';
        clearButton.textContent = 'Clear';
        clearButton.addEventListener('click', function () {
            document.querySelector(inputSelector).value = '';
            instance.clear();
        });

        footer.appendChild(okButton);
        footer.appendChild(clearButton);

        instance.calendarContainer.appendChild(footer);
    }
}
function getMatchEndDateTime(matchDisplayName) {
    // Assuming the end date and time are part of the matchDisplayName and need to be extracted
    const parts = matchDisplayName.split(" ");
    const matchDateStr = parts.slice(-2).join(" ");
    const matchDate = flatpickr.parseDate(matchDateStr, "d-m-Y H:i");

    // Extract date and time separately for maxDate and maxTime
    return {
        date: matchDate,
        time: matchDate.toTimeString().slice(0, 5) // Format time as HH:mm
    };
}

// Handle match selection change
matchSelect.addEventListener('change', function () {
    const matchDisplayName = this.value;
    const matchDateTime = getMatchEndDateTime(matchDisplayName);
    
    // Update Flatpickr configurations
    const startPicker = flatpickr('#fantasyStartDate', {
        dateFormat: 'd-m-Y H:i',
        enableTime: true,
        minDate: 'today',
        maxDate: matchDateTime.date,
        maxTime: matchDateTime.time,
    });
});
function isValidTeamName1(value) {
    const emojiRegex = /[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}\u{1FB00}-\u{1FBFF}]/u;
    const alphanumericRegex = /^[a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*$/u;
    
    // Check for emoji
    if (emojiRegex.test(value)) {
        return false; // Invalid if emoji found
    }
    
    // Check for alphanumeric and spaces
    if (!alphanumericRegex.test(value)) {
        return false; // Invalid if non-alphanumeric characters found
    }
    
    // Check for purely numeric input
    if (/^\d+$/.test(value)) {
        return false; // Invalid if input is purely numeric
    }
    
    return true; // Valid input
}
function sanitizePriceInput(inputElement) {
    inputElement.addEventListener('input', function () {
        let value = this.value.replace(/\D/g, ''); // Remove any non-digit characters
        this.value = value; // Optionally, you can update the input value
    });
}
sanitizePriceInput(priceInput);


      function updatePriceList() {
        priceList.innerHTML = '';
        prices.forEach((price, index) => {
          const div = document.createElement('div');
          div.className = 'price-item';
          div.innerHTML = `${price} <span onclick="removePrice(${index})">&times;</span>`;
          priceList.appendChild(div);
        });
      }

      // Function to add a new price
      addPriceButton.addEventListener('click', function () {
        const price = parseFloat(priceInput.value);
        if (!isNaN(price) && !prices.includes(price)) {
          prices.push(price); // Add the new price to the prices array
          updatePriceList();
          priceInput.value = '';
          if (checkPriceValidation()) {
            checkPriceValidation();
          }
        }
      });





      function checkPriceValidation() {
        if (prices.length === 0) {
          errorPrice.innerHTML = 'Price list cannot be empty';
          errorPrice.style.display = 'block';
          return false
        } else {
          errorPrice.style.display = 'none';
          return true
        }
      }


      window.removePrice = function (index) {
        prices.splice(index, 1);
        updatePriceList();
        // if (checkPriceValidation()) {
        //   checkPriceValidation()
        // }
      }

      document.getElementById('winningPrizeInput').addEventListener('input', function (event) {
    let value = this.value.replace(/\D/g, ''); // Remove any non-digit characters
    
    if (value) {
        this.value = `${value}x`; // Append 'X' at the end
    } else {
        this.value = ''; // Ensure the input is empty when value is empty
    }
});

await fetchMatchData();
document.getElementById('winningPrizeInput').addEventListener('keydown', function (event) {
    if (event.key === 'Backspace' || event.key === 'Delete') {
        let value = this.value.replace('x', ''); // Remove 'X' if present
        value = value.slice(0, -1); // Remove the last digit
        
        if (value) {
            this.value = `${value}x`; // Append 'X' at the end
        } else {
            this.value = ''; // Ensure the input is empty when value is empty
        }
        
        // Prevent the default backspace action
        event.preventDefault();
    }
});

      
      function checkPoolOverlap(selectMatch, poolName, startDate1, existingPool) {
        const startDate = document.getElementById('fantasyStartDate').value;
        if (!existingPool || existingPool.length === 0) {
          return { matchNameOverlap: false, poolNameOverlap: false, };
        }

        const normalizedName = selectMatch.trim().toLowerCase();
        const normalizedShortName = poolName.trim().toLowerCase();

        const matchNameOverlap = existingPool.some(match => {
          const normalizedExistingName = match.select_match.match_display_name.trim().toLowerCase();
          return normalizedExistingName === normalizedName;
        });

        const poolNameOverlap = existingPool.some(league => {
          const normalizedExistingShortName = league.pool_name.trim().toLowerCase();
          return normalizedExistingShortName === normalizedShortName;
        });

        // const dateOverlap = existingPool.some(match => {
        //   const matchStartDateStr1 = match.fantacy_start_date;
        //   ;
        //   const [day, month, year] = matchStartDateStr1.split(/[- ]+/);
        //   const matchStartDateStr = `${day}-${month}-${year}`;

        //   const startDateStr = startDate;
        //   const [startDay, startMonth, startYear] = startDateStr.split(/[- ]+/);
        //   const startDateObj = `${startDay}-${startMonth}-${startYear}`;

        //   return startDateObj === matchStartDateStr;
        // });
        // console.log('Date Overlap:', dateOverlap);
        console.log(matchNameOverlap , "okkk2")
        return { matchNameOverlap, poolNameOverlap, };
      }

      function validateMatchSelection() {
        const matchSelect = document.getElementById('matchSelect');
        const errorSpan = document.getElementById('error-match');

        if (!matchSelect || !errorSpan) {
          console.error('Match selection elements not found');
          return false;
        }



        function validate() {
          if (matchSelect.value === '') {
            errorSpan.innerHTML = 'Please select a match';
            errorSpan.style.display = 'inline';
            return false;
          } else {
            errorSpan.style.display = 'none';
            return true;
          }
        }


        matchSelect.addEventListener('change', validate);
        // poolSelect.addEventListener('change', validate1);
        return validate()
      }


      function validateoPoolSelection() {

        const poolSelect = document.getElementById('poolTypeSelect');
        const errorpoolSpan = document.getElementById('error-pool');


        if (!poolSelect || !errorpoolSpan) {
          console.error('Pool selection elements not found');
          return false;
        }


        function validate() {
          if (poolSelect.value === '') {
            errorpoolSpan.innerHTML = 'Please select a pool';
            errorpoolSpan.style.display = 'inline';
            return false;
          } else {
            errorpoolSpan.style.display = 'none';
            return true;
          }
        }

        poolSelect.addEventListener('change', validate);
        return validate()
      }

      function validateInput(inputId, errorId, validationFunction, emptyMessage, invalidMessage) {
    const inputElement = document.getElementById(inputId);
    const errorElement = document.getElementById(errorId);

    function validate() {
        const value = inputElement.value.trim();
        if (value === '') {
            errorElement.innerHTML = emptyMessage;
            errorElement.style.display = 'inline';
            return false;
        } else if (!validationFunction(value)) {
            errorElement.innerHTML = invalidMessage;
            errorElement.style.display = 'inline';
            return false;
        } else {
            errorElement.style.display = 'none';
            return true;
        }
    }

    inputElement.addEventListener('input', validate);
    inputElement.addEventListener('change', validate);

    return validate();
}
      function validateMatchDates() {
        const startDate = document.getElementById('fantasyStartDate');
        // const endDate = document.getElementById('fantasyEndDate');
        const errorSpanStart = document.getElementById('error-fantacy-start-date');
        // const errorSpanEnd = document.getElementById('error-fantacy-end-date');

        function validateDate(dateInput, errorSpan) {
          if (!dateInput || !errorSpan) {
            console.error('Date input elements not found');
            return false;
          }

          function validate() {
            if (!dateInput.value) {
              errorSpan.innerHTML = 'Please select a date';
              errorSpan.style.display = 'inline';
              return false;
            } else {
              errorSpan.style.display = 'none';
              return true;
            }
          }

          dateInput.addEventListener('change', validate);
          return validate();
        }

        const validStartDate = validateDate(startDate, errorSpanStart);
        // const validEndDate = validateDate(endDate, errorSpanEnd);

        // return validStartDate && validEndDate;
        return validStartDate ;
      }


      function validateForm() {
        const MatchValid = validateMatchSelection();
        const PoolValid = validateoPoolSelection();

        const isValidPoolName = validateInput(
          'poolNameInput',
          'error-pool-name',
          isValidTeamName1,
          'Please enter a pool name',
          'Please enter a valid pool name'
        );

        const isValidWinningPrice = validateInput(
          'winningPrizeInput',
          'error-win-price',
          isValidTeamName1,
          'Please enter a winning price',
          'Please enter a valid winning price'
        );

        isPriceAdd = checkPriceValidation()
        // const teamValid = validateTeamSelection();
        // const playerValid = validatePlayerSelection();
        const datesValid = validateMatchDates();

        return MatchValid && datesValid && PoolValid && isValidPoolName && isPriceAdd && isValidWinningPrice;
      }

      async function submitPoolData(data, method) {
        const formData = new FormData();


        formData.append('select_match', data.select_match);
        formData.append('pool_type', data.pool_type);
        formData.append('pool_name', data.pool_name);

        // Append each price individually
        data.price.map(price => {
          formData.append('price', [price]);
        });

        formData.append('winning_price', data.winning_price);
        formData.append('fantacy_start_date', data.fantacy_start_date);
        // formData.append('fantacy_end_date', data.fantacy_end_date);

        // Log formData keys and values
        formData.forEach((value, key) => {
          console.log(key, value);
        });
        try {
          const response = await fetch(`https://krinik.pythonanywhere.com/add_pool_get/pool_id/${id}/`, {
            method: method,
            body: formData
          });

          if (!response.ok) {
            throw new Error('Failed to add pool');
          }

          const responseData = await response.json();
          console.log('Success:', responseData.data);
          // window.location.href = './manage-pool.html';/
          const urlParams = new URLSearchParams({
            select_match: data.select_match,
            pool_name: data.pool_name
                    });
                    switch (data.pool_type) {
                        case 'Silver':
                            window.location.href = 'pool-A.html?' + urlParams.toString();
                            break;
                        case 'Platinum':
                            window.location.href = 'pool-B.html?' + urlParams.toString();
                            break;
                        case 'Gold':
                            window.location.href = 'pool-C.html?' + urlParams.toString();
                            break;
                        default:
                            // Redirect to a default page or handle unexpected cases
                            console.log('Unknown pool type:', payload.pool_type);
                            break;
                    }
        } catch (error) {
          console.error('Error:', error);
          alert('An error occurred while adding the pool. Please try again later.');
        }
      }





      document.getElementById('submitButton').addEventListener('click', async function () {
        // const selectMatch = matchSelect.value; // Get selected match display name
        const selectMatch = document.getElementById('matchSelect').value;
        //  const priceValues1 = document.getElementById('priceList');
        const poolType = document.getElementById('poolTypeSelect').value;
        const poolName = document.getElementById('poolNameInput').value;
        const winningPrize = parseFloat(document.getElementById('winningPrizeInput').value);
        const fantasyStartDate = document.getElementById('fantasyStartDate').value;
        // const fantasyEndDate = document.getElementById('fantasyEndDate').value;
        const startDate1 = fantasyStartDate;

        // const currentData = {
        //   select_match: matchSelect.value,
        //   pool_type: document.getElementById('poolTypeSelect').value,
        //   pool_name: document.getElementById('poolNameInput').value,
        //   price: prices, // Ensure this variable is defined
        //   winning_price: parseFloat(document.getElementById('winningPrizeInput').value),
        //   fantacy_start_date: document.getElementById('fantasyStartDate').value,
        //   fantacy_end_date: document.getElementById('fantasyEndDate').value
        // };



        const currentData = {
          select_match: selectMatch,
          pool_type: poolType,
          pool_name: poolName,
          price: prices,
          winning_price: winningPrize,
          fantacy_start_date: fantasyStartDate,
          // fantacy_end_date: fantasyEndDate
        };

        // currentData.forEach(play =>{
        //   console.log(currentData)
        // })
        console.log(currentData, "ok")
        const overlapResult = checkPoolOverlap(selectMatch, poolName, startDate1, existingPool);


        if (validateForm()) {

          const hasMatchChanged = currentData.select_match !== initialData.select_match;
          const hasDateChanged = currentData.fantacy_start_date !== initialData.fantacy_start_date;


          const hasPoolTypeChanged = currentData.pool_type !== initialData.pool_type;
          const hasPoolNameChanged = currentData.pool_name !== initialData.pool_name;
          const hasWinningPriceChanged = currentData.winning_price !== initialData.winning_price;
          const hasPriceChanged = currentData.price !== initialData.price;

          if (hasPoolTypeChanged || hasWinningPriceChanged || hasPriceChanged || hasDateChanged) {
            if (confirm("Are you sure you want to add this match?")) {
              try {
                submitPoolData(currentData, 'PATCH');
              } catch (error) {
                console.error('Error:', error);
              }
            }
          // } else if(hasMatchChanged && hasPoolNameChanged ){
          //   if (overlapResult.matchNameOverlap && overlapResult.poolNameOverlap) {
          //       document.getElementById('error-match').innerHTML = 'Match already exists';
          //       document.getElementById('error-match').style.display = 'inline';
          //       document.getElementById('error-pool-name').innerHTML = 'Pool name already exists';
          //       document.getElementById('error-pool-name').style.display = 'inline';
          //     } else {
          //       if (confirm("Are you sure you want to add this match?")) {
          //         try {
          //           submitPoolData(currentData, 'PATCH');
          //         } catch (error) {
          //           console.error('Error:', error);
          //         }
          //       }
          //     }
          // }
          // else if (hasMatchChanged ) {
          //     if (overlapResult.matchNameOverlap && overlapResult.poolNameOverlap) {
          //       document.getElementById('error-match').innerHTML = 'Match already exists';
          //       document.getElementById('error-match').style.display = 'inline';
          //       // document.getElementById('error-pool-name').innerHTML = 'Pool name already exists';
          //       // document.getElementById('error-pool-name').style.display = 'inline';
          //     } else {
          //       if (confirm("Are you sure you want to add this match?")) {
          //         try {
          //           submitPoolData(currentData, 'PATCH');
          //         } catch (error) {
          //           console.error('Error:', error);
          //         }
          //       }
          //     }
          //   }
          //   else if(hasPoolNameChanged){
          //     if (overlapResult.matchNameOverlap && overlapResult.poolNameOverlap) {
          //       // document.getElementById('error-match').innerHTML = 'Match already exists';
          //       // document.getElementById('error-match').style.display = 'inline';
          //       document.getElementById('error-pool-name').innerHTML = 'Pool name already exists';
          //       document.getElementById('error-pool-name').style.display = 'inline';
          //     } else {
          //       if (confirm("Are you sure you want to add this match?")) {
          //         try {
          //           submitPoolData(currentData, 'PATCH');
          //         } catch (error) {
          //           console.error('Error:', error);
          //         }
          //       }
          //     }
            }      
            else {
              if (confirm("Are you sure you want to add this match?")) {
                try {
                  submitPoolData(initialData, 'PATCH');
                } catch (error) {
                  console.error('Error:', error);
                }
              }
            }
          } else {
          console.log('Form validation failed. Please check all fields.');
        }

      });
    });

  </script>
</body>

</html>